#!/usr/bin/env bash

#? {cmd} DEST -I INCLUDES... PROTOS...
#? example: {cmd} src -I ../../msgs ../../msgs/proto/*.proto
#? 
#? DEST is the root of the output source
#? INCLUDES are the root directories from which to gather proto files
#? PROTOS are generated in paths relative to the provided includes
#? 
#? input: {cmd} src -I ../../msgs ../../msgs/proto/example.proto
#? output: "Proto/Example.elm" within the "src" directory

function checkDep() {
    ! hash "${1}" 2>/dev/null && \
        echo "requires ${1}" >&2 && exit 1
}

function checkDepOr() {
    ! (hash "${1}" 2>/dev/null || hash "${2}" 2>/dev/null) && \
        echo "requires ${1} or ${2}" >&2 && exit 1
}

function yudodis() {
    [[ "$(uname -s)" == "Darwin" && "${1}" == "sed" ]] && \
        echo "darwin requires gsed" >&2 && exit 1
}

checkDep "protoc"
checkDep "protoc-gen-elm"
checkDep "elm-format"
checkDepOr "sed" "gsed"
checkDepOr "realpath" "grealpath"

function getDepOr() {
    local ret="${1}"
    hash "${2}" 2>/dev/null && ret="${2}"
    echo "${ret}"
}

function getDestinationDir() {
    ! mkdir -p "${1}" 2>/dev/null && echo "cannot make directory '${1}'" >&2 && exit 1
    echo "${1}"
}

function getIncludeDirs() {
    local args=("${@}")
    local flag="-I"
    local rets=()

    for (( i=0; i<${#args}; i++ )); do
        local arg="${args[i]}"
        local argv="${args[i+1]}"

        [[ "${arg}" == "${flag}" ]] && rets+=("${arg}" "${argv}") && ((i++)); continue
        [[ "${arg}" == "${flag}"* ]] && rets+=("${arg}") && continue
    done

    echo "${rets[@]}"
}

function getSourceFiles() {
    local args=("${@}")
    local rets=()

    for arg in ${args[@]}; do
        [[ "${arg}" == "-"* ]] && continue

        [[ ! -f "${arg}" ]] && echo "non-file '${arg}'" >&2 && exit 1

        rets+=("${arg}")
    done

    [[ ${#rets[@]} == 0 ]] && echo "must provide one or more files" >&2 && exit 1
    echo "${rets[@]}"
}

function filterProto {
    local in="${1}"
    local out="${2}"
    local sedCmd="$(getDepOr "sed" "gsed")"

    cat "${in}" | \
        # delete consecutive empty lines (simplifies multi-line empty message deletion)
        ${sedCmd} '/^$/N;/^\n$/D' | \
        # delete service definitions 
        ${sedCmd} '/^service/,/^}$/d' | \
        # delete annotations.proto (contains proto2 dependency)
        ${sedCmd} '/annotations.proto/d' | \
        # delete empty messages (single line)
        ${sedCmd} '/^message.*{\s*}/d' | \
        # delete empty messages (multiple lines)
        ${sedCmd} '/^message.*/ {N;N; /^message.*{[\s|\n]*\}/d}' | \
        # delete consecutive empty lines (again, some have likely been created)
        ${sedCmd} '/^$/N;/^\n$/D' | \
        # delete last line if empty
        ${sedCmd} '${/^$/d}' \
        >> "${out}"

    return $?
}

function trip {
    [[ ${1} > 0 ]] && exit ${1}
}

function main {
    local cleanups=()
    function runCleanups() {
        for cleanup in "${cleanups[@]}"; do
            eval ${cleanup}
        done
    }
    trap "runCleanups" EXIT RETURN

    local skip=1
    local dstDir incs files
    dstDir="$(getDestinationDir "${1}")"; trip $? 
    ((skip+=1))
    incs=($(getIncludeDirs ${@:${skip}})); trip $?
    ((skip+=${#incs[@]}))
    files=($(getSourceFiles ${@:$skip})); trip $?

    local token="xxfiltxx"
    local filtfiles=()

    for file in ${files[@]}; do
        local filtfile="${file/\.proto/${token}.proto}"
        ! filterProto "${file}" "${filtfile}" && continue
        filtfiles+=("${filtfile}")
        cleanups+=("rm ${filtfile}")
    done

    local timeref="${dstDir}/time_ref"
    touch "${timeref}"
    cleanups+=("rm ${timeref}")

    protoc ${incs[@]} --elm_out="${dstDir}" ${filtfiles[@]} > /dev/null 2>&1

    find "${dstDir}" -name "*.elm" -newer "${timeref}" | while read file; do
      elm-format --yes "${file}" > /dev/null
      sed -i 's/'${token}'//g' ${file}

      local newfile=${file/${token}/}
      [[ "${file}" != "${newfile}" ]] && mv "${file}" "${newfile}"
    done
}

function doc() {
    function display() {
        local cmd="$(basename "${0}")"
        local rpCmd="$(getDepOr "realpath" "grealpath")"

        grep '^#?' $(${rpCmd} "${0}") | \
            sed 's/#?\s*//g' | \
            sed 's/{cmd}/'${cmd}'/g'
    }

    local args=("${@}")

    for arg in ${args[@]}; do
        [[ "${arg}" == "-h" || "${arg}" == "-help" || "${arg}" == "--help" ]] && \
            display && exit 0
    done
}

doc ${@}

yudodis "$(getDepOr "sed" "gsed")"

main ${@}
