#!/usr/bin/env bash

#? {cmd} DEST [-I INCLUDES]... SOURCE...
#? example: {cmd} . -I../../../includes/dir ../../msgs/*.proto

! hash protoc 2>/dev/null && echo "requires protoc" >&2 && exit 1
! hash protoc-gen-elm 2>/dev/null && echo "requires protoc" >&2 && exit 1
! hash elm-format 2>/dev/null && echo "requires elm-format" >&2 && exit 1

function getDestinationDir() {
    [[ ! -d "${1}" ]] && echo "arg must be directory '${1}'" >&2 && exit 1

    echo "${1}"
}

function getIncludeDirs() {
    local args=("${@}")
    local rets=()

    local i arg argv
    for (( i=0; i<${#args}; i++ )); do
        arg=${args[i]}
        argv=${args[i+1]}

        [[ "${arg}" == "-I" ]] && rets+=("${arg}" "${argv}") && ((i++)) && continue
        [[ "${arg}" == "-I"* ]] && rets+=("${arg}") && continue
    done

    local ret
    for ret in ${rets[@]}; do
        ret="${ret#"-I"}"

        [[ "${ret}" == "" ]] && continue
        [[ ! -d "${ret}" ]] && echo "non-dir '${ret}'" >&2 && exit 1
    done

    echo "${rets[@]}"
}

function getSourceFiles() {
    local args=("${@}")
    local rets=()

    for arg in ${args[@]}; do
        [[ "${arg}" == "-"* ]] && continue

        [[ ! -f "${arg}" ]] && echo "non-file '${arg}'" >&2 && exit 1

        rets+=("${arg}")
    done

    [[ ${#rets[@]} == 0 ]] && echo "must provide one or more files" >&2 && exit 1

    echo "${rets[@]}"
}

function filterProto {
    local in="${1}"
    local out="${2}"

    local sedCmd=sed
    hash gsed 2>/dev/null && sedCmd=gsed

    cat ${in} | \
        # delete consecutive empty lines (simplifies multi-line empty message deletion)
        ${sedCmd} '/^$/N;/^\n$/D' | \
        # delete service definitions 
        ${sedCmd} '/^service/,/^}$/d' | \
        # delete annotations.proto (contains proto2 dependency)
        ${sedCmd} '/annotations.proto/d' | \
        # delete empty messages (single line)
        ${sedCmd} '/^message.*{\s*}/d' | \
        # delete empty messages (multiple lines)
        ${sedCmd} '/^message.*/ {N;N; /^message.*{[\s|\n]*\}/d}' | \
        # delete consecutive empty lines (again, some have likely been created)
        ${sedCmd} '/^$/N;/^\n$/D' | \
        # delete last line if empty
        ${sedCmd} '${/^$/d}' \
        >> ${out}
}

function trip {
    [[ ${1} > 0 ]] && exit ${1}
}

function main {
    local skip=1
    local dstDir incs files

    dstDir="$(getDestinationDir "${1}")"; trip $? 
    ((skip+=1))

    incs=($(getIncludeDirs ${@:${skip}})); trip $?
    ((skip+=${#incs[@]}))

    files=($(getSourceFiles ${@:$skip})); trip $?

    local tmpDir="$(mktemp -t -d $(basename ${0}).XXXXXX)"

    function cleanup {
        [[ ! -d "${1}" || "${1}" == "/" ]] && echo "will not remove '${1}'" >&2 && return
        rm -rf "${1}"
    }
    trap "cleanup ${tmpDir}" EXIT

    for file in ${files[@]}; do
        filterProto "${file}" "${tmpDir}/$(basename ${file})"
    done

    protoc ${incs[@]} -I"${tmpDir}" --elm_out="${tmpDir}" "${tmpDir}"/*.proto > /dev/null 2>&1

    find "${tmpDir}" -name "*.elm" -exec elm-format --yes {} \; > /dev/null
    
    local foundDir
    find "${tmpDir}" -name "*.elm" -printf '%P\n' | while read file; do
        foundDir="$(dirname ${file})"
        if [[ "${foundDir}" != "." ]]; then
            mkdir -p "${dstDir}/${foundDir}"
        fi

        cp "${tmpDir}/${file}" "${dstDir}/${file}"
    done
}

function doc() {
    function show() {
        local cmd="$(basename "${0}")"
        local docs="$(grep '^#?' $(realpath "${0}"))"

        echo "${docs}" | \
            sed 's/#?\s*//g' | \
            sed 's/{cmd}/'${cmd}'/g'
    }

    local args=("${@}")

    for arg in ${args[@]}; do
        [[ "${arg}" == "-h" || "${arg}" == "-help" || "${arg}" == "--help" ]] && show && exit 0
    done
}

doc ${@}

main ${@}
